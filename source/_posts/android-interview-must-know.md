---
title: Android面试必知必会
---
## Android

### 一， Android的四大组件

> 所有android应用都是由四大组件组成的：Activity，BroadcastReceiver，Service，ContentProvider

- Activity：最基本的组件，一个就是一个屏幕，通常都被实现为一个独立的类
- BroadcastReceiver：使用它对外部事件进行过滤，接收并做出响应
- Service：一个服务是具有一个较长生命周期且没有用户界面的程序。
- ContentProvider：使一个应用程序的指定数据集可以提供给其他应用程序。

### 二，Activity的生命周期

> 参考文章：[深入理解Activity的生命周期](https://www.jianshu.com/p/fb44584daee3)

![](https://cdn.jsdelivr.net/gh/fushaolei/img/20200607214328.png)

| 方法        | 作用                                                         |
| ----------- | ------------------------------------------------------------ |
| `onCreate`  | 进行初始化工作，此时**Activity还在后台，不可见**             |
| `onStart`   | 此时Actvity**已经可见**，但是还没出现在前台，**不可交互**    |
| `onResume`  | 此时Activity出现在前台并**可交互**                           |
| `onPause`   | 当Activity要跳到另一个Activity或应用正常退出时都会执行这个方法。此时Activity在**前台**并可见 |
| `onStop`    | 此时Activity已经**不可见**了，（但是Activity对象还在内存中，没有被销毁） |
| `onDestroy` | 这个阶段Activity被销毁                                       |
| `onRestart` | restart表示重新开始，Activity在这时**可见**，当用户按Home键切换到桌面后又切回来或者从后一个Activity切回前一个Activity就会触发这个方法。这里一般不做什么操作。 |

###  三，Activity的四个启动方法

> ~~给👴整懵逼了，看都看不懂~~

| 启动模式       | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| standard       | **标准模式**，每创建一个Activity，都会在任务栈中添加一个实例 |
| singleTop      | **栈顶复用**，如果打开的Activity在任务栈顶，就不在创建，直接复用，如果不在栈顶，就重新创建一个 |
| singleTask     | **栈内复用**，如果打开的Activity在任务栈中，就删除此Activity上面所有的Activity，知道该Activity在栈顶，如果打开的Activity没在任务栈中，直接创建一个新的Activity实例入栈 |
| singleInstance | **全局唯一**（单例模式），给每一个Activity创建一个任务栈，**独占一个栈**，打开Activity的时候就对所有的任务进行查询，如果有此Activity，直接复用，不用重新创建 |

### 四，Fragment的生命周期

| 方法                  | 作用                                                         |
| --------------------- | ------------------------------------------------------------ |
| `onAttach()`          | Fragment**和Activity建立关联**的时候调用，被附加到Activity中去。 |
| `onCreate()`          | 系统会在创建Fragment时调用此方法。可以**初始化一段资源文件**等等。 |
| `onCreateView()`      | 系统会在Fragment**首次绘制其用户界面时调用此方法**。 要想为Fragment绘制 UI，从该方法中返回的 View 必须是Fragment布局的根视图。如果Fragment未提供 UI，您可以返回 null。 |
| `onViewCreated()`     | 在Fragment被绘制后，调用此方法，可以**初始化控件资源**。     |
| `onActivityCreated()` | 当onCreate()，onCreateView()，onViewCreated()方法执行完后调用，也就是Activity被渲染绘制出来后。 |
| `onPause()`           | 系统将此方法作为用户离开Fragment的第一个信号（但并不总是意味着此Fragment会被销毁）进行调用。 通常可以在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回）。 |
| `onDestroyView()`     | Fragment中的布局**被移除**时调用。                           |
| `onDetach()`          | Fragment和Activity解除关联的时候调用。                       |



### 五，service的生命周期

#### 通过startService方式启动服务

1. onCreate：首次创建服务时由系统调用
2. onStartCommand：每次客户端通过调用显式启动服务时
3. onDestroy

#### 通过bindService方式启动服务

1. onCreate：首次创建服务时由系统调用
2. onBind：绑定服务
3. onUnBind：解绑服务
4. onDestroy

## Java

### 一，==和equal的区别

先讲==

- 如果是基本类型话，比较的是值
- 如果是引用数据类型的话，比较的是他们在内存中的地址值

然后是equal

- 引用类型：默认情况下，比较的是地址值。

### 二，stringbufffer与stringbuilder的区别

- StringBuffer是**线程安全**的
- StringBuilder是**非线程安全**的（简单来说就是StringBuilder的append方法没有实现同步锁synchronized机制，而StringBuffer实现了，这也是StringBuffer效率比较低的原因）

#### 扩展：什么叫线程安全，什么叫线程不安全

- **线程安全**
  - 就是**多线程**访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程**读/写**完，其他线程才可使用。不会出现数据不一致或者数据污染。
- **线程不安全**
  - 就是**不提供数据访问保护**，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。



### 三，List，Set，Map的区别

- `List`的元素以线性方式存储，可以存放重复对象
- `Set`中的对象不按特定(HashCode)的方式排序，并且没有重复对象
- `Map`是一种把键对象和值对象映射的集合，它的每一个元素都包含一个键对象和值对象，是无序的

### 四，重载和重写有什么区别

- 重载：是在一个类里面，方法名字相同，**而参数不同，返回类型也可以不同** 的方法
- 重写：在子类存在方法与父类的方法的名字相同，**且参数的个数一样，返回值类型也一样**的方法

### 五，请简述面向对象

- 封装：把一个**对象的属性私有化，同时提供一些可以被外界访问的属性的方法**
- 继承：继承是指**当A类继承B类时（关键字`extends`），A类就自动获得B类的所有功能**
- 多态：**针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法** （重载，重写）

### 六，抽象和接口的区别

- 最大的一个区别：就是`interface`中只能定义方法，而不能有方法的实现，而在`abstract class`中则可以既有方法的具体实现，又有 没有具体实现的抽象方法
- 一个类只能有一个继承类，但可以实现多个接口

### 七，ArrayList和LinkedList有什么区别

- **ArrayList**：底层数据结构是**数组**，查询快，增删慢，线程不安全，效率高，可以存储重复元素
- **LinkedList** 底层数据结构是**链表**，查询慢，增删快，线程不安全，效率高，可以存储重复元素

#### 扩展一：数组和链表有什么区别

- 数组是基于索引的数据结构，其中每个元素与索引相关联。
- 链表 依赖于引用，其中每个节点由数据和对前一个和下一个元素的引用组成。

### 八，基本类型

| 基本类型  | 位数 | 字节 | 默认值  | 对应的包装器类 |
| --------- | ---- | ---- | ------- | -------------- |
| `int`     | 32   | 4    | 0       | `Integer`      |
| `short`   | 16   | 2    | 0       | `Short`        |
| `long`    | 64   | 8    | 0L      | `Long`         |
| `byte`    | 8    | 1    | 0       | `Byte`         |
| `char`    | 16   | 2    | 'u0000' | `Character`    |
| `float`   | 32   | 4    | 0f      | `Float`        |
| `double`  | 64   | 8    | 0d      | `Double`       |
| `boolean` | 1    |      | false   | `Boolean`      |

> 注意:

1. Java 里使用`long`类型的数据一定要在数值后面加上**L**，否则将作为整型解析
2. char a = 'h' char :单引号，String a = "hello" ：双引号

## 九，HashSet和HashMap的区别

| HashMap                                     |                           HashSet                            |
| :------------------------------------------ | :----------------------------------------------------------: |
| HashMap实现了**Map接口**                    |                   HashSet实现了**Set接口**                   |
| HashMap储存键值对                           |                     HashSet仅仅存储对象                      |
| 使用put()方法将元素放入map中                |                 使用add()方法将元素放入set中                 |
| HashMap中使用键对象来计算hashcode值         | HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false |
| HashMap比较快，因为是使用唯一的键来获取对象 |                  HashSet较HashMap来说比较慢                  |

### 十，如何实现多线程

- 继承Thread类
- 实现Runnable接口

## 网络原理

### 一，Http和Https的区别

- Http协议以**明文方式**发送内容，安全性较差，80端口
- Https是在Http下加入SSL层进行加密，安全性高，443端口

### 二，Get和Post有什么区别

- Get：当客户端要从服务器中读取某个资源时用Get，Get参数通过URL传递，传递的参数有长度限制，不能用来传敏感信息
- Post：当客户端要给服务器提供信息较多的时候可用Post，Post将请求参数封装在HTTP请求数据中，可以传输大量数据，传参方式也比Get更安全

### 三，TCP和UDP有什么区别

- TCP：面向连接的可靠传输协议
  - 发送数据前必须建立连接
  - 提供可靠交付
  - 面向字节流
  - 有拥塞控制机制
  - 仅支持一对一
  - 首部开销大
- UDP：非连接协议
  - 发送数据前不需要建立连接
  - 尽最大努力交付，不保证可靠传输
  - 面向报文
  - 无拥塞控制
  - 支持一对一，多对一，多对一，多对多
  - 首部开销小

### 四，简单解释下TCP建立连接的三次握手和断开连接的四次挥手

- 三次握手
  - A向B发送请求，告知B：我要和你通信
  - B收到A的请求后，返回消息给A：我收到你的请求了，你可以传数据了
  - A收到后再发送一个确认应答，确认已收到B的数据段，三次握手完成
- 四次挥手
  - A向b提出停止连接的请求
  - B收到请求后确认连接将关闭
  - B再提出反方向的关闭请求给A
  - A对B的请求进行确认，四次挥手结束
